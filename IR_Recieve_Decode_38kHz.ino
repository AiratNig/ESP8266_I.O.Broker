//В первую очередь надо понять, что мы получаем от приемника и как это интерпретировать. Поэтому, я написал небольшой скетч, который может вам пригодиться, если вы захотите разобраться с сигналами для вашей модели пульта: 

/* IRtest - для экспериментов с ИК-приемником
   Фиксирует переключения уровня сигнала от IR-приемника, Заносит отсчеты времени в массив.
   Выводит полученные данные в терминальное окно. */

unsigned long T[250]; //сюда будем помещать временные отсчеты;
int S0;                      //начальный уровень сигнала;
int S;                        //текущий уровень сигнала;

void setup(){
  Serial.begin(9600);  
  pinMode(2,INPUT);             //IR-приемник подключен к выводу "2" Arduino;
}

void loop(){
  S0 = digitalRead(2);
  S = S0;
 
  // заполняем массив данными:
  for(int i=0; i<250; i++){
    while(S == digitalRead(2)); //ждем смены сигнала; 
    T[i] = micros();            //текущее время в мкс;
    S = digitalRead(2);         //новый уровень сигнала;
  } 

  // уровень сигнала в состоянии ожидания.
  Serial.println(S0, BIN);   

  // выводим массив в терминал:
  S=S0;
  for(int i=1; i<250; i++){
    S = !S;                   //уровень сигнала чередуется
    Serial.print(i,DEC);        //нумерация строк для наглядности;
    Serial.print("  "); 
    Serial.print(S,BIN);  //текущий уровень сигнала.   
    Serial.print(" : ");
    printMillis(T[i] - T[i-1]); //выводим длительность сигнала в МиллиСекудах. 
    Serial.println(" ms."); 
  } 
}

// получает время в микросекундах  и выводит его в терминал  в миллисекундах.
void printMillis(unsigned long D){
  unsigned long Millis, Micros;
  Millis = D/1000;
  Micros = D - Millis*1000;
  Serial.print(Millis,DEC);
  Serial.print(",");
  Serial.print(Micros,DEC);
}

//Загружаем в Arduino, открываем терминал, жмем на пульте кнопки. Когда массив заполнится контроллер выдаст данные в терминал.     
//1
//1  0 : 8,912 ms.
//2  1 : 4,556 ms.
//3  0 : 0,524 ms.
//4  1 : 0,612 ms.
//5  0 : 0,520 ms.
//6  1 : 1,712 ms.
//7  0 : 0,524 ms.
//8  1 : 1,724 ms.
//9  0 : 0,540 ms.
//10  1 : 0,584 ms.
//11  0 : 0,524 ms.
//12  1 : 0,608 ms.
///...
//65  0 : 0,512 ms.
//66  1 : 1,724 ms.
//67  0 : 0,524 ms.
//68  1 : 39,896 ms.
//69  0 : 8,912 ms.
//70  1 : 2,320 ms.
//71  0 : 0,524 ms.
//72  1 : 956,580 ms.
//73  0 : 8,912 ms.
//74  1 : 4,560 ms.
//75  0 : 0,512 ms.
//76  1 : 0,620 ms.
//...
 
//Анализируя результат, можно понять следующее:

  //  В состоянии ожидания сигнал находится в высоком уровне. 
//    Код клавиши состоит из 32 бит. Старшие два байта для данного пульта всегда одинаковые. А код клавиши определялся двумя младшими байтами. 
//    Каждый бит кодируется последовательностью из низкого затем высокого уровней: 0,55+0,55= 1,1мс соответствует "0" , а 0,5+1,7= 2,2мс - соответствует "1".
//    Перед началом передачи 32 битов кода идет последовательность:  8,9+4,5=  13,4мс. - "Сейчас начнется передача новой команды"
//    Последовательность  8,9+2,3 = 11,2мс. означает "повтор предыдущей команды"
//    Строка 71 и 72. Очевидно, что это низкий и высокий уровень во время ожидания между нажатиями кнопки.
//    Возможно это было связанно с плохим контактом, но иногда я получал ложные переключения менее 1мс, которые влияли на конечный результат. 
//    Зная, какими должны быть первые два байта, мы можем игнорировать команды с ошибками. Кроме того, мы можем использовать несколько пультов, если нам не хватит кнопок на одном.


//Теперь собственно программа: 
//Вместо того, чтобы непрерывно опрашивать состояние сигнала с ИК-приемника и тратить на это кучу драгоценного времени, как это реализовано в решениях, найденных мной в Интернете, воспользуемся прерываниями.
//Функция - "обработчик прерывания" будет вызываться каждый раз, когда сигнал переходит из "высокого" уровня в "низкий". 
//Очень важно для такой функции быстро отработать и вернуть управление обратно. 
//Если ваш контроллер кроме считывания команд с пульта ДУ занимается еще какими-нибудь полезными но "долгими" делами, логично организовать что-то вроде очереди сообщений (FIFO) и помещать коды кнопок туда. И опрашивать очередь уже в основном цикле программы. Тогда вы их не пропустите.  
//Можно конечно сделать это все в виде библиотеки и "спрятать" в класс и обработчик и очередь сообщений. Но, на мой взгляд, оно того не стоит. Ведь для каждого пульта обработчик нужен свой.   
 
volatile unsigned long IR_KEY;   //код кнопки на пульте

void setup() {                
  Serial.begin(9600);
  pinMode(2, INPUT);    // ИК приемник подключим сюда        
  IR_KEY = 0;
  attachInterrupt(0,IRinterrupt,FALLING); // назначим прерывание 
}

void loop() {
 if(IR_KEY) {
   Serial.println(IR_KEY,HEX); //выводим код в терминал.
   IR_KEY = 0;
 }
}

/* обработчик прерывания*/
void IRinterrupt(){
  static unsigned long key, prevTime;
  unsigned long currTime, d;
  currTime = micros();
  d = currTime - prevTime;
  if(d < 1100) return;        // "дребезг"
  if(d < 1400){               // "0"
    key = key << 1;
    prevTime = currTime;
    return; }
  if(d < 2400){               // "1"
    key = key << 1;
    key++;
    prevTime = currTime;
    return;}
  if(d < 13000) IR_KEY = key; // код кнопки получен
  prevTime = currTime;
}
